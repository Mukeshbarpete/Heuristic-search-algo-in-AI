# -*- coding: utf-8 -*-
"""AI_assign05.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J3NDsxZlrBXXTegRErUrR_nVUdUvY1zo
"""

import copy
import random
import time

def get_initialstate():
  lst = [5,-1,8,4,2,1,7,3,6]
  return lst

#find number of tiles which are rightly placed
def placed(state):
  count = 0
  for i in range(0,9):
    if state[i]!=-1:
      if state[i]==i+1:
        count = count+1;
  return count

#find number of tiles which are wrongly placed
def misplaced(state):
  count = 0
  for i in range(0,9):
    if state[i]!=-1:
      if state[i]!=i+1:
        count = count+1;
  return count

#calculating fitness fuction-1 for hueristics search difference between placed tiles and misplaced tiles
def fitness1(state):
  return placed(state) - misplaced(state) + 9

#calculating fitness fuction-2 for hueristics search multiplying  misplaced tiles and respective position

def fitness2(state):
  ans =0
  for i in range(0,9):
    if state[i-1]!=-1:
      ans+=state[i-1]*(i+1)
  return ans

#create population for next iteration
def create_population(initial):
    population = []
    for i in range(0,5):
      population.append(copy.deepcopy(initial))
      initial = initial[::-1]
      population.append(copy.deepcopy(initial))
      initial[i+1], initial[8-i] = initial[8-i], initial[i+1]
    return population
# initial = get_initialstate()
# create_population(initial)

#caculate fitness value for population
def population_fitness(population, fitness):
  lst = []
  for i in population:
    lst.append(fitness(i))
  return lst

def find_cromosome(lst_fitness, population):
  best_crom = population[0]
  best_fitness = lst_fitness[0]
  for i in range(1,len(population)):
    if(lst_fitness[i]>best_fitness):
      best_crom = population[i]
      best_fitness = lst_fitness[i]
  return best_fitness, best_crom

#using roulettewheel method
def parent_selection(population,Value,rouletteWheel):
    r = list(range(0,Value))
    first = random.choice(r)
    r.remove(first)
    second = random.choice(r)
    return population[rouletteWheel[first]],population[rouletteWheel[second]]

#crossover of two parent and get better to offstring
def crossover(parent1,parent2):
    r = random.randint(0,8)
    offspring1 = []
    offspring2 = []

    for i in range(0,r+1):
        offspring1.append(parent1[i])
        offspring2.append(parent2[i])

    for i in range(0,9):
        if parent2[i] not in offspring1:
            offspring1.append(parent2[i])

    for i in range(0,9):
        if parent1[i] not in offspring2:
            offspring2.append(parent1[i])

    return offspring1,offspring2

def mutation(offSpring1,offSpring2):
    r = list(range(0,9))
    pt1 = random.choice(r)
    r.remove(pt1)
    pt2 = random.choice(r)
    offSpring1[pt1],offSpring1[pt2] = offSpring1[pt2],offSpring1[pt1]
    offSpring2[pt1],offSpring2[pt2] = offSpring2[pt2],offSpring2[pt1]
    return offSpring1,offSpring2

#genetic algorithm
def genetic_algo(initial,target,fitness):
  startTime = time.time()
  timeLimit = 100
  optimal_path = 1
  if(initial==target):
    return [True,0,0,round(time.time()-startTime,3)]
  bestcromosome = initial
  population = create_population(initial)
  while(True):
     node_explor = 1
     #check target in population
     for i in population:
       if(i== target):
          return [True,optimal_path,node_explor,round(time.time()-startTime,3)]
       node_explor+=1
     optimal_path+=1
     if(time.time()-startTime>timeLimit):
       return [False,optimal_path,node_explor,round(time.time()-startTime,3)]
     #find best cromosome in population
     lst_fitness = population_fitness(population,fitness)
     best_fitness,bestcromosome = find_cromosome(lst_fitness, population)
     newpopulation = []
     rouletteWheel_list = []
     for i in range(0,len(population)):
       k=0
       while(k<=lst_fitness[i]):
         rouletteWheel_list.append(i)
         k+=1
     n = 0
     while n<5:
       parent1, parent2 = parent_selection(population,len(rouletteWheel_list), rouletteWheel_list)
       prob = random.uniform(0,1)
       if prob>0.6 :
        #APPLYING CROSSOVER
        offSpring1,offSpring2 = crossover(parent1,parent2)
        #print(offSpring1,offSpring2)
        #APPLYING MUTATION
        prob = random.uniform(0,1)
        if prob<0.2 :
          offSpring1,offSpring2 = mutation(offSpring1,offSpring2)
          #print(offSpring1,offSpring2)
          #ADDING NEW POPULATION TO THE LIST
        newpopulation.append(copy.deepcopy(offSpring1))
        newpopulation.append(copy.deepcopy(offSpring2))
        n += 1
     population = newpopulation

#Driver code
initial = get_initialstate()
target = [1,2,3,4,5,6,7,8,-1]
lst = genetic_algo(initial,target,fitness1)
print(initial)
print(target)
print("genetic algorithm for fitness fuction_1 \nf1() = placed tiles - misplaced tiles + 9")
if(lst[0]==True):
  print("Goal found successfully!")
  print("Total number of states explored : ",lst[1]*10+lst[2])
  print("Total number of states to the optimal path :", lst[1]*10)
  print("Time taken for execution: ",lst[3])
  print("Optimal Path : ",lst[1])
else:
  print("Goal not Found!")
  print("Total number of states explored : ",lst[1]*10+lst[2])
  print("Total number of states to the optimal path :", lst[1]*10)
  print("Time taken for execution: ",lst[3])

print("\n")
lst = genetic_algo(initial,target,fitness2)
print("genetic algorithm for fitness fuction_2 \nf2() = sum of the product of the tiles number with respect  ")
if(lst[0]==True):
  print("Goal found successfully!")
  print("Total number of states explored : ",lst[1]*10+lst[2])
  print("Total number of states to the optimal path :", lst[1]*10)
  print("Time taken for execution: ",lst[3])
  print("Optimal Path : ",lst[1])
else:
  print("Goal not Found!")
  print("Total number of states explored : ",lst[1]*10+lst[2])
  print("Total number of states to the optimal path :", lst[1]*10)
  print("Time taken for execution: ",lst[3])