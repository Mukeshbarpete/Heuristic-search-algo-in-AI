# -*- coding: utf-8 -*-
"""AI_assign3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FoJnLXe9IHG3-kzJ-mCN1i4p9-D16f6b
"""

#importing required module
import copy
import time

#function for user input
def getinitialstate():
    print("Enter 1 for Random grid.\nEnter 2 for user input .")
    choice = int(input("Enter your choice : "))
    lst = []
    if(choice==2):
        n = int(input("Enter order of Puzzle (blank = -1): "))
        for i in range(1, n+1):
            print("Enter row ", i, ": ", sep=" ", end=" ")
            lst.append(list(map(int, input().split())))
    else:
        lst = [[3, 2, 1],
                [4, 5, 6],
                [8, 7, -1]]

    return lst

#generate targetstate
def gettarget(n):
    k = 1
    target = []
    for i in range(n):
        temp = []
        for j in range(n):
            temp.append(k)
            k+=1
        target.append(temp)
    target[n-1][n-1] = -1
    return target

#left shift of blank
def leftstate(initialstate, x, y):
    initialstate[x][y],initialstate[x][y-1] = initialstate[x][y-1], initialstate[x][y]
    return initialstate

#right shift of blank
def rightstate(initialstate, x, y):
    initialstate[x][y], initialstate[x][y + 1] = initialstate[x][y + 1], initialstate[x][y]
    return initialstate

#up shift of blank
def upstate(initialstate, x, y):
    initialstate[x-1][y], initialstate[x][y] = initialstate[x][y], initialstate[x-1][y]
    return initialstate

#down shift of blank
def downstate(initialstate, x, y):
    initialstate[x][y], initialstate[x+1][y] = initialstate[x+1][y], initialstate[x][y]
    return initialstate

#compare search state and target state
def compare_initial_target(initialstate, targetstate):
  for i in range(len(initialstate)):
        for j in range(len(initialstate[i])):
            if initialstate[i][j] != targetstate[i][j]:
                return False
  return True

#finding position of blank
def find_position_of_blank(statelist):
    for i in range(len(statelist)):
        for j in range(len(statelist[i])):
            if statelist[i][j] == -1:
                return (i, j)
    return (2, 2)

#find mahatten distance
def find_manhatten_distance(initialstate):
    d = {1:[0,0], 2:[0,1], 3:[0,2], 4:[1,0], 5:[1,1], 6:[1,2], 7:[2.,0], 8:[2,1]}
    manhatten = 0
    for i in range(len(initialstate)):
      for j in range(len(initialstate[i])):
        if initialstate[i][j]!=-1:
          x, y = d[initialstate[i][j]]
          manhatten = manhatten + abs(x-i) + abs(y-j)
    return manhatten;
# initialstate = getinitialstate()
# find_manhatten_distance(initialstate)

#find sum  of misplaced tiles
def find_number_of_misplaced_tiles(initialstate):
    k = 1
    misplaced = 0
    for i in range(len(initialstate)):
      for j in range(len(initialstate[i])):
        if initialstate[i][j]!=-1:
          if(k!=initialstate[i][j]):
            misplaced = misplaced + 1
        k = k+1
    return misplaced

# initialstate = getinitialstate()
# find_number_of_misplaced_tiles(initialstate)

def print_state(initialstate):
  for i in range(len(initialstate)):
    for j in range(len(initialstate[i])):
      print(initialstate[i][j],sep=" ",end=" ")
    print()

#puzzle solved for h(n) = 0
def hill_climb(initialstate,targetstate, h_function):
    startTime = time.time()
    lenoflist = len(initialstate)
    stepcount = 0
    curr_h_value = h_function(initialstate)
    curr_state = initialstate
    lst = []
    count = 0
    while(count<=100):
        path = ""
        if(compare_initial_target(initialstate, targetstate)):
            return [stepcount, lst, True, time.time()-startTime]
        stepcount = stepcount + 1
        x, y = find_position_of_blank(initialstate)
        if(x<lenoflist-1):
            downlist = downstate(copy.deepcopy(initialstate), x, y)
            temp = h_function(downlist)
            if(curr_h_value >= temp):
              path = "down"
              curr_h_value = temp
              curr_state = downlist
        if(x>0):
            uplist = upstate(copy.deepcopy(initialstate), x, y)
            temp = h_function(uplist)
            if(curr_h_value >= temp):
              path = "up"
              curr_h_value = temp
              curr_state = uplist
        if (y > 0):
            leftlist = leftstate(copy.deepcopy(initialstate), x, y)
            temp = h_function(leftlist)
            if(curr_h_value >= temp):
              path = "left"
              curr_h_value = temp
              curr_state = leftlist
        if(y<lenoflist-1):
            rightlist = rightstate(copy.deepcopy(initialstate), x, y)
            temp = h_function(rightlist)
            if(curr_h_value >= temp):
              path = "right"
              curr_h_value = temp
              curr_state = rightlist
        if(curr_state==initialstate):
          return [stepcount, lst, False, time.time()-startTime]
        if(curr_h_value==h_function(initialstate)):
          count+=1
        else:
          count = 0
        initialstate = curr_state
        lst.append(path)
    return [stepcount, lst, False, time.time()-startTime]

Ainitialstate = getinitialstate()
targetstate = gettarget(len(initialstate))
print("initial state :")
print_state(initialstate)
print("target state")
print_state(targetstate)
print("Hill Climing Search with manhatten Distance ")
lst1 = hill_climb(initialstate, targetstate, find_manhatten_distance)
if(lst1[2]==True):
  print("Goal found Successfully")
  print("Total number of states explored: ", len(lst1[1]))
  print("Total number of states to the optimal path : ",len(lst1[1]))
  print("Optimal Path : ",lst1[1])
  print("Optimal Path Cost: ",lst1[0])
  print("Time taken for execution : ",lst1[3])
else:
  print("Goal not found !")
  print("Total number of states explored: ", len(lst1[1])+1)
  print("Time taken for execution : ",round(lst1[3],3))

print("\n\nHill Climing Search with misplaced tiles ")
lst1 = hill_climb(initialstate, targetstate, find_number_of_misplaced_tiles)
if(lst1[2]==True):
  print("Goal found Successfully")
  print("Total number of states explored: ", len(lst1[1]))
  print("Total number of states to the optimal path : ",len(lst1[1]))
  print("Optimal Path : ",lst1[1])
  print("Optimal Path Cost: ",lst1[0])
  print("Time taken for execution : ",round(lst1[3],3))
else:
  print("Goal not found !")
  print("Total number of states explored: ", len(lst1[1])+1)
  print("Time taken for execution : ",round(lst1[3],3))