# -*- coding: utf-8 -*-
"""AI_assign04.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oIz3my57SNLGDKS1Z6WvCfQKIVfKXljp
"""

#importing required module
import copy
import random
import math
import time

def getinitialstate():
    # print("Enter 1 for Random grid.\nEnter 2 for user input .")
    # choice = int(input("Enter your choice : "))
    choice = 1
    lst = []
    if(choice==2):
        n = int(input("Enter order of Puzzle (blank = -1): "))
        for i in range(1, n+1):
            print("Enter row ", i, ": ", sep=" ", end=" ")
            lst.append(list(map(int, input().split())))
    else:
        lst = [[3, 2, 1],
                [4, 5, 6],
                [8, 7, -1]]
    # with open('input.txt') as f:
    #   readline = f.readlines()
    # lst = []
    # for i in readline:
    #   lst.append(list(map(int, i)))

    return lst

#generate targetstate
def gettarget(n):
    k = 1
    target = []
    for i in range(n):
        temp = []
        for j in range(n):
            temp.append(k)
            k+=1
        target.append(temp)
    target[n-1][n-1] = -1
    return target

#left shift of blank
def leftstate(initialstate, x, y):
    initialstate[x][y],initialstate[x][y-1] = initialstate[x][y-1], initialstate[x][y]
    return initialstate

#right shift of blank
def rightstate(initialstate, x, y):
    initialstate[x][y], initialstate[x][y + 1] = initialstate[x][y + 1], initialstate[x][y]
    return initialstate

#up shift of blank
def upstate(initialstate, x, y):
    initialstate[x-1][y], initialstate[x][y] = initialstate[x][y], initialstate[x-1][y]
    return initialstate

#down shift of blank
def downstate(initialstate, x, y):
    initialstate[x][y], initialstate[x+1][y] = initialstate[x+1][y], initialstate[x][y]
    return initialstate

#compare search state and target state
def compare_initial_target(initialstate, targetstate):
  for i in range(len(initialstate)):
        for j in range(len(initialstate[i])):
            if initialstate[i][j] != targetstate[i][j]:
                return False
  return True

#finding position of blank
def find_position_of_blank(statelist):
    for i in range(len(statelist)):
        for j in range(len(statelist[i])):
            if statelist[i][j] == -1:
                return (i, j)
    return (2, 2)

#find mahatten distance
def find_manhatten_distance(initialstate):
    d = {1:[0,0], 2:[0,1], 3:[0,2], 4:[1,0], 5:[1,1], 6:[1,2], 7:[2.,0], 8:[2,1]}
    manhatten = 0
    for i in range(len(initialstate)):
      for j in range(len(initialstate[i])):
        if initialstate[i][j]!=-1:
          x, y = d[initialstate[i][j]]
          manhatten = manhatten + abs(x-i) + abs(y-j)
    return manhatten;
# initialstate = getinitialstate()
# find_manhatten_distance(initialstate)

#find sum  of misplaced tiles
def find_number_of_misplaced_tiles(initialstate):
    k = 1
    misplaced = 0
    for i in range(len(initialstate)):
      for j in range(len(initialstate[i])):
        if initialstate[i][j]!=-1:
          if(k!=initialstate[i][j]):
            misplaced = misplaced + 1
        k = k+1
    return misplaced

# initialstate = getinitialstate()
# find_number_of_misplaced_tiles(initialstate)

def print_state(initialstate):
  for i in range(len(initialstate)):
    for j in range(len(initialstate[i])):
      print(initialstate[i][j],sep=" ",end=" ")
    print()

#generate random probability function
def probability():
  return random.uniform(0,1)

#cooling function
def cooling_function(h1,h2,t):
  dg = h2-h1
  return math.exp(dg/t)

#h1()*h2()
def f_h1_h2(initialstate):
  return find_manhatten_distance(initialstate)*find_number_of_misplaced_tiles(initialstate)

#puzzle solved for h(n) = 0
def simulated_annealing(initialstate,targetstate, h_function):
    startTime = time.time()
    alpha = 0.01
    lenoflist = len(initialstate)
    stepcount = 0
    curr_h_value = h_function(initialstate)
    lst = []
    lst_temp = []
    temperature = 1000
    parent = initialstate
    curr_state = initialstate

    while(temperature>0): 
        lst1 = []
        path = ""
        curr_state = initialstate
        if(compare_initial_target(initialstate, targetstate)):
            return [stepcount, lst, True, time.time()-startTime,lst_temp]
        stepcount = stepcount + 1
        x, y = find_position_of_blank(initialstate)
        if(x<lenoflist-1):
            downlist = downstate(copy.deepcopy(initialstate), x, y)
            temp = h_function(downlist)
            if(parent!=downlist):
              lst1.append([downlist,temp,"down"])
              if(curr_h_value > temp):
                path = "down"
                curr_h_value = temp
                curr_state = downlist
        if(x>0):
            uplist = upstate(copy.deepcopy(initialstate), x, y)
            temp = h_function(uplist)
            if(parent!=uplist):
              lst1.append([uplist, temp,"up"])
              if(curr_h_value > temp):
                path = "up"
                curr_h_value = temp
                curr_state = uplist
        if (y > 0):
            leftlist = leftstate(copy.deepcopy(initialstate), x, y)
            temp = h_function(leftlist)
            if(parent!=leftlist):
              lst1.append([leftlist,temp,"left"])
              if(curr_h_value > temp):
                path = "left"
                curr_h_value = temp
                curr_state = leftlist
        if(y<lenoflist-1):
            rightlist = rightstate(copy.deepcopy(initialstate), x, y)
            temp = h_function(rightlist)
            if(parent!=rightlist):
              lst1.append([rightlist,temp,"right"])
              if(curr_h_value > temp):
                path = "right"
                curr_h_value = temp
                curr_state = rightlist 
        #print(len(lst1))
        if(curr_state!=initialstate):
            lst.append(path)
          
        else:
          index = math.floor(random.uniform(0, len(lst1)))
          temp_state = lst1[index][0]
          temp = lst1[index][1]
          path = lst1[index][2]
          cool_fvalue = cooling_function(temp,curr_h_value,temperature)
          prob = probability()
          
          #print(cool_fvalue,prob)
          if(prob < cool_fvalue):
            curr_state = temp_state
            curr_h_value = temp
            lst.append(path)

        parent = initialstate
        initialstate = curr_state
        temperature = temperature - alpha
    return [stepcount, lst, False, time.time()-startTime]

initialstate = getinitialstate()
targetstate = gettarget(len(initialstate))
print("initial state :")
print_state(initialstate)
print("target state")
print_state(targetstate)

print("simulated annealing Search with manhatten Distance ")
lst1 = simulated_annealing(initialstate, targetstate, find_manhatten_distance)
print("Heuristics chosen :h1() = manhatten Distance")
print("Temperature chosen :",1000)
print("cooling function chosen :[temperature - alpha] here alpha is 0.01")
if(lst1[2]==True):
  print("Goal found Successfully")
  print("Total number of states explored: ", len(lst1[1]))
  print("Total number of states to the optimal path : ",len(lst1[1]))
  print("Optimal Path : ",lst1[1])
  print("Optimal Path Cost: ",lst1[0])
  print("Time taken for execution : ",round(lst1[3],3))
else:
  print("Goal not found !")
  #print("Optimal Path : ",lst1[1])
  print("Optimal Path Cost: ",lst1[0])
  print("Total number of states explored: ", len(lst1[1])+1)
  print("Time taken for execution : ",round(lst1[3],3))

print("\n\nsimulated annealing Search with misplaced tiles ")
print("Heuristics chosen :h2() = misplaced tiles")
print("Temperature chosen :",1000)
print("cooling function chosen :[temperature - alpha] here alpha is 0.01")
lst1 = simulated_annealing(initialstate, targetstate, find_number_of_misplaced_tiles)
if(lst1[2]==True):
  print("Goal found Successfully")
  print("Total number of states explored: ", len(lst1[1]))
  print("Total number of states to the optimal path : ",len(lst1[1]))
  print("Optimal Path : ",lst1[1])
  print("Optimal Path Cost: ",lst1[0])
  print("Time taken for execution : ",round(lst1[3],3))
else:
  print("Goal not found !")
  #print("Optimal Path : ",lst1[1])
  print("Total number of states explored: ", len(lst1[1])+1)
  print("Time taken for execution : ",round(lst1[3],3))

print("\n\nsimulated annealing Search with h1()*h2() ")
print("Heuristics chosen :h() = h1()*h2()")
print("Temperature chosen :",1000)
print("cooling function chosen :[temperature - alpha] here alpha is 0.01")
lst1 = simulated_annealing(initialstate, targetstate, f_h1_h2)
if(lst1[2]==True):
  print("Goal found Successfully")
  print("Total number of states explored: ", len(lst1[1]))
  print("Total number of states to the optimal path : ",len(lst1[1]))
  print("Optimal Path : ",lst1[1])
  print("Optimal Path Cost: ",lst1[0])
  print("Time taken for execution : ",round(lst1[3],3))
else:
  print("Goal not found !")
  #print("Optimal Path : ",lst1[1])
  print("Total number of states explored: ", len(lst1[1])+1)
  print("Time taken for execution : ",round(lst1[3],3))